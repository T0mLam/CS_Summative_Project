from typing import Tuple, List
import matplotlib.pyplot as plt
import networkx as nx
import random as rand

from node import Node
from heap import MinHeap
from randomised_set import RandomisedSet
from score_generation import RandomScoreGenerator


class Graph:
    """
    An undirected and connected graph data structure storing uniquely indexed nodes with weighted edges.

    Notes:
        Class attributes can only be accessed by class methods.

    Attributes:
        G: An instance of the Graph class of the networkx module.
        unconnected_edges: An instance of the RandomisedSet class storing all unconnected edges.
        node_map: A hashmap mapping the index of the node to its Node object.
        node_idx_count: An integer count for indexing new nodes.
        num_nodes: The total number of nodes in the graph.
        num_edges: The total number of edges in the graph.
        edge_mean: The mean weight of the generated edges.
        edge_sd: The standard deviation of the weight of the generated edges.

    Methods:
        generate_random_nodes: Generate a random number of nodes.
        generate_random_edges: Generate a random number of weighted edges.
        add_edge_to_graph: Add an edge with random weight to the graph.
        delete_edge: Delete an edge from the graph.
        shortest_path: Find the shortest path between 2 nodes.
    """

    def __init__(self,
                 init_num_nodes: int = 0,
                 add_num_edges: int = 0,
                 edge_mean: int = 5,
                 edge_sd: int | float = 3) -> None:
        """
        Construct all attributes of the graph data structure.

        Args:
            init_num_nodes: Number of randomly generated nodes during initialization.
            add_num_edges: Number of additional randomly generated edges, after 
                           generating n - 1 edges to connect all nodes, n = init_num_nodes.
            edge_mean: The mean weight of the generated edges.
            edge_sd: The standard deviation of the weight of the generated edges.

        Raises:
            TypeError: Errors caused by incompatible data types of input parameters.
            ValueError: Errors caused by negative inputs of parameters.
        """
        if not all([isinstance(init_num_nodes, int),
                    isinstance(add_num_edges, int),
                    isinstance(edge_mean, int)]):
            raise TypeError("Input parameters 'init_num_nodes', 'init_num_edges' and 'edge_mean' must be integers")
        
        if not isinstance(edge_sd, (int, float)):
            raise TypeError("Input parameter 'edge_sd' must be an integer or a float")

        if min(init_num_nodes, 
               add_num_edges, 
               edge_mean, 
               edge_sd) < 0:
            raise ValueError("All input parameters must be non-negative")
        
        self.G = nx.Graph()
        self.rsg = RandomScoreGenerator()
        self.unconnected_edges = RandomisedSet()
        self.node_map = {}
        self.node_idx_count = 1
        self.num_nodes = 0
        self.num_edges = 0
        self.edge_mean = edge_mean
        self.edge_sd = edge_sd

        self.generate_random_nodes(init_num_nodes)
        self.__randomly_connect_all_nodes()
        self.generate_random_edges(add_num_edges)

    def generate_random_nodes(self, 
                              num: int | None = None,
                              low: int = 10,
                              high: int = 15) -> None:
        """
        Generate a random number of nodes in the graph.

        Args:
            num: An integer representing the fixed number of nodes to be generated (optional).
            low: The minimum number of nodes generated by the method (default = 10).
            high: The minimum number of nodes generated by the method (default = 15).

        Raises:
            TypeError: Errors caused by non-integer parameters input.
            ValueError: Errors caused by non-negative parameters input or the invalid ranges of 'low' and 'high'.
        """
        # Check data type of input parameters
        if not all([isinstance(num, (int, None)),
                   isinstance(low, int),
                   isinstance(high, int)]):
            raise TypeError("All input parameters must be integers")
    
        # Check values of input parameters
        if min(low, high) < 0:
            raise ValueError("Input parameters 'low' and 'high' must be non-negative")
        if low > high:
            raise ValueError("Input parameter 'high' must be equal or larger than 'low'")
        
        # Generate random num of nodes if the user does not define a fixed num
        if num is None:
            num = rand.randint(low, high)

        if num < 0:
            raise ValueError("Input parameter 'num' must be non-negative")

        self.num_nodes += num

        # Generate nodes
        while num:
            self.node_map[self.node_idx_count] = Node(self.node_idx_count)
            self.G.add_node(self.node_idx_count)

            node_indices = list(self.node_map.keys())
            self.unconnected_edges.add_edges_from_node(self.node_idx_count, node_indices)

            self.node_idx_count += 1
            num -= 1

    def generate_random_edges(self,
                              num: int | None = None,
                              low: int = 5,
                              high: int = 10) -> None:
        """
        Generate a random number of edges in the graph.

        Args:
            num: An integer representing the fixed number of edges to be generated (optional).
            low: The minimum number of edges generated by the method (default = 5).
            high: The minimum number of edges generated by the method (default = 10).

        Raises:
            TypeError: Errors caused by non-integer parameters input.
            ValueError: Errors caused by non-negative parameters input or the invalid ranges of 'low' and 'high'.
        """
        # Check data type of input parameters
        if not all([isinstance(num, (int, None)),
                   isinstance(low, int),
                   isinstance(high, int)]):
            raise TypeError("All input parameters must be integers")

        if min(low, high) < 0:
            raise ValueError("All input parameters must be non-negative")
        if low > high:
            raise ValueError("Input parameter 'high' must be equal or larger than 'low'")
        
        # Generate random num of edges if the user does not define a fixed num
        if num is None:
            num = rand.randint(low, high)

        if num < 0:
            raise ValueError("Input parameter 'num' must be non-negative")

        # Get the maximum number of edges that could exist in the graph
        max_num_edges = self.__get_max_num_edges()
            
        # Generate edges while the number of edges in the graph has not reached the maximum
        while num and self.num_edges < max_num_edges:
            # Get the start and end node of the random edge
            start, end = self.unconnected_edges.get_random_edge()

            # Add an edges between the 2 nodes
            self.add_edge_to_graph(start, end)

            # Decrease the remaining num of edges to be generated
            num -= 1

    def add_edge_to_graph(self, idx1: int, idx2: int) -> None:
        """
        Add an edge to the graph with random integer weight from 1 to 10.

        Args:
            idx1: The index of the first node.
            idx2: The index of the second node.

        Raises:
            TypeError: Errors caused by non-integer parameters input.
            ValueError: Errors caused by invalid range or non-existing node parameters input.
        """
        # Check data type of input parameters
        if (not isinstance(idx1, int) or 
            not isinstance(idx2, int)):
            raise TypeError("Input parameters 'idx1' and 'idx2' must be integers")
        
        # Check value ranges of input parameters
        if idx1 == idx2:
            raise ValueError("The value of 'idx1' cannot be the same as 'idx2'")
        if (idx1 not in self.node_map or 
            idx2 not in self.node_map):
            raise ValueError("The input node(s) do(es) not exist in the graph")
        
        # Get the start and end node objects from the node_map 
        start_node = self.node_map[idx1]
        end_node = self.node_map[idx2]

        # Randomly generate weight for the new edge
        weight = self.rsg.generate_random_edge(mean=self.edge_mean, sd=self.edge_sd)

        # Set the nodes as their neighors
        start_node.add_neighbour(end_node, weight)
        end_node.add_neighbour(start_node, weight)

        # Add the edge to the networkx visualization
        self.G.add_edge(idx1, idx2, weight=weight)

        # Remove the edge from the available edges set and add it to the unavailable edges set
        if (idx1, idx2) in self.unconnected_edges:
            self.unconnected_edges.remove_edge_from_set(idx1, idx2)

        # Increase the num of edges in the graph
        self.num_edges += 1

    def delete_edge(self, idx1: int, idx2: int) -> None:
        """
        Delete the edge between two existing nodes

        Args:
            idx1: The index of the first node.
            idx2: The index of the second node.
        """

        # Check if nodes are in the graph
        if(idx1 in self.G and idx2 in self.G):

            # Check if the nodes have an edge
            if(self.G.has_edge(idx1, idx2)):

                # Deleting the edge
                self.G.remove_edge(idx1, idx2)

                # Decrease the num of edges in the graph
                self.num_edges -= 1
                return True 
            else:
                return False
        else:
            return False

    def shortest_path(self, starting_node: int, ending_node: int) -> int:
        """
        Find the shortest path between starting node and ending node in the graph.

        Args:
            starting_node: Index of the starting node.
            ending_node: Index of the ending node.

        Returns:
            The length of the shortest path or -1 if the path does not exist.
        """

        # Check if both starting node and ending node are in the graph
        if starting_node not in self.node_map or ending_node not in self.node_map:
            raise ValueError('The input node(s) do(es) not exist in the graph')

        # Create priority queue as the object of MinHeap class
        priority_queue = MinHeap([(0, self.node_map[starting_node])])  
        visited_nodes = set()

         # Checking each node until all nodes are visited
        while len(priority_queue) > 0:  
            # Pop the node with the smallest distance to the ending_node
            current_distance, current_node_object = priority_queue.pop()  
            current_node = current_node_object.get_index()

            # If the current node is the ending_node, the current distance will be returned
            if current_node == ending_node:
                return current_distance

             # Go through each neighbor of the current_node
            if current_node not in visited_nodes:
                visited_nodes.add(current_node)

                # If the neighbor was not visited, it will be added to priority queue
                for neighbor_object, weight in current_node_object.get_neighbours():
                    if neighbor_object.get_index() not in visited_nodes:
                        new_distance = current_distance + weight

                        # Use push method to add neighbors
                        priority_queue.push((new_distance, neighbor_object))  
        # If the ending node was not reached, return -1
        return -1

    def __get_max_num_edges(self) -> int:
        """
        Calculate the maximum number of edges can be connected in the graph.

        Returns:
            An integer representing the maximum number of edges.
        """
        n = self.num_nodes
        return n * (n - 1) // 2
    
    def __randomly_connect_all_nodes(self) -> None:
        """
        Randomly shuffle the list of nodes and connect them.
        """
        # Get the all the node indicies in the graph and shuffle them
        node_indices = list(self.node_map.keys())
        shuffled_nodes = rand.shuffle(node_indices)

        # Connect each node with its previous node
        for i in range(1, len(node_indices)):
            node1 = self.node_map[node_indices[i]]
            node2 = self.node_map[node_indices[i - 1]]

            weight = self.rsg.generate_random_edge(mean=self.edge_mean, sd=self.edge_sd)

            node1.add_neighbour(node2, weight=weight)
            node2.add_neighbour(node1, weight=weight)

            self.G.add_edge(node_indices[i], node_indices[i - 1], weight=weight)

            # Remove the edge from the unconnected edges set
            self.unconnected_edges.remove_edge_from_set(node_indices[i], node_indices[i - 1])
            
            self.num_edges += 1
            
    def graph_visualize(self, with_labels=True, node_size=700) -> None:
        """
        Graphical visualization of the graph using matplotlib libary.

        Args:
            with_labels (bool): If True, nodes will show their ID as label.
            node_size (int): The size of the nodes.
        """
        # Assigning a position for each node of the graph using the srping layout algorithm
        node_position = nx.spring_layout(self.G)

        # Drawing nodes of the graph
        nx.draw_networkx_nodes(self.G, node_position, node_size=node_size)

        # Drawing edges of the nodes and set the width of each edge to be proportional to its weight
        edge_width = list(nx.get_edge_attributes(self.G, 'weight').values())
        nx.draw_networkx_edges(self.G, node_position, alpha=0.5, width=edge_width)
        
        # If the labels exist - draw them
        if with_labels:
            nx.draw_networkx_labels(self.G, node_position, font_size=12)
            edge_labels = nx.get_edge_attributes(self.G, 'weight')
            nx.draw_networkx_edge_labels(self.G, node_position, edge_labels)

        # Axis are not needed for the project
        plt.axis('off') 

        # Visualize the graph
        plt.show() 


if __name__ == '__main__':
    graph = Graph(init_num_nodes=4, add_num_edges=8)
    graph.graph_visualize()
    # set weight in __randomly_connect_all_nodes and add_edge_to_graph  
