from typing import Dict

import matplotlib.pyplot as plt
import networkx as nx
import random as rand

from .score_generation import RandomScoreGenerator as RSG
from .utils.heap import MinHeap
from .utils.node import Node
from .utils.randomised_set import RandomisedSet


class Graph:
    """A randomly generated undirected and fully connected graph data structure.

    Notes:
        Class attributes should not be directed accessed.

    Attributes:
        G: An instance of the Graph class of the networkx module.
        node_position: The positions of each nodes in the networkx graph.
        unconnected_edges: An instance of the RandomisedSet class storing all unconnected edges.
        node_map: A hashmap mapping the index of the node to its Node object.
        node_idx_count: An integer count for indexing new nodes.
        num_nodes: The total number of nodes in the graph.
        num_edges: The total number of edges in the graph.
        edge_mean: The mean weight of the generated edges.
        edge_sd: The standard deviation of the weight of the generated edges.

    Methods:
        generate_random_nodes: Generate a random number of nodes.
        generate_random_edges: Generate a random number of weighted edges.
        add_edge_to_graph: Add an edge with random weight to the graph.
        shortest_path: Find the shortest path between 2 nodes.
    """

    def __init__(self,
                 init_num_nodes: int = 0,
                 add_num_edges: int = 0,
                 edge_mean: int = 5,
                 edge_sd: int | float = 3) -> None:
        """Construct all attributes of the graph data structure.

        Args:
            init_num_nodes (int): Number of randomly generated nodes during initialization.
            add_num_edges (int): Number of additional randomly generated edges, after 
                           generating n - 1 edges to connect all nodes, n = init_num_nodes.
            edge_mean (int): The mean weight of the generated edges.
            edge_sd (int, float): The standard deviation of the weight of the generated edges.

        Raises:
            TypeError: Errors caused by incompatible data types of input parameters.
            ValueError: Errors caused by negative inputs of parameters.
        """
        if not all([isinstance(init_num_nodes, int),
                    isinstance(add_num_edges, int),
                    isinstance(edge_mean, int)]):
            raise TypeError("Input parameters 'init_num_nodes', 'init_num_edges' and 'edge_mean' must be integers")
        
        if not isinstance(edge_sd, (int, float)):
            raise TypeError("Input parameter 'edge_sd' must be an integer or a float")

        if min(init_num_nodes, 
               add_num_edges, 
               edge_mean, 
               edge_sd) < 0:
            raise ValueError("All input parameters must be non-negative")
        
        self.G = nx.Graph()
        self.node_position = None
        self.unconnected_edges = RandomisedSet()
        self.node_map = {}
        self.node_idx_count = 1
        self.num_nodes = 0
        self.num_edges = 0
        self.edge_mean = edge_mean
        self.edge_sd = edge_sd

        self.generate_random_nodes(init_num_nodes)
        self.__randomly_connect_all_nodes()
        self.generate_random_edges(add_num_edges)
    
    def __str__(self) -> str:
        """Return the basic information about the Graph object.
        
        Returns:
            A string including the number of edges (|E|), the number of vertices (|V|),
            the mean weight of the edges (E.x̄) and the standard deviation of the edge weights (E.σ).
        """
        return f'Graph: |E| = {self.num_edges}, |V| = {self.num_nodes}, E.x̄ = {self.edge_mean}, E.σ = {self.edge_sd}'

    def generate_random_nodes(self, 
                              num: int | None = None,
                              low: int = 10,
                              high: int = 15) -> None:
        """Generate a random number of nodes in the graph.

        Args:
            num (int): An integer representing the fixed number of nodes to be generated (optional).
            low (int): The minimum number of nodes generated by the method (default = 10).
            high (int): The minimum number of nodes generated by the method (default = 15).

        Raises:
            TypeError: Errors caused by non-integer parameters input.
            ValueError: Errors caused by non-negative parameters input or the invalid ranges of 'low' and 'high'.
        """
        # Check data type of input parameters
        if not all([isinstance(num, (int, None)),
                   isinstance(low, int),
                   isinstance(high, int)]):
            raise TypeError("All input parameters must be integers")
    
        # Check values of input parameters
        if min(low, high) < 0:
            raise ValueError("Input parameters 'low' and 'high' must be non-negative")
        if low > high:
            raise ValueError("Input parameter 'high' must be equal or larger than 'low'")
        
        # Generate random num of nodes if the user does not define a fixed num
        if num is None:
            num = rand.randint(low, high)

        # Raise a value error if the user enters a negative number of nodes
        if num < 0:
            raise ValueError("Input parameter 'num' must be non-negative")

        self.num_nodes += num

        # Generate nodes
        while num:
            # Add the new node to the node map and the networkx graph
            self.node_map[self.node_idx_count] = Node(self.node_idx_count)
            self.G.add_node(self.node_idx_count)

            # Add all possible edges to the unconnected edges set
            node_indices = list(self.node_map.keys())
            self.unconnected_edges.add_edges_from_node(self.node_idx_count, node_indices)

            self.node_idx_count += 1
            num -= 1

    def generate_random_edges(self,
                              num: int | None = None,
                              low: int = 5,
                              high: int = 10) -> None:
        """Generate a random number of edges in the graph.

        Args:
            num (int): An integer representing the fixed number of edges to be generated (optional).
            low (int): The minimum number of edges generated by the method (default = 5).
            high (int): The minimum number of edges generated by the method (default = 10).

        Raises:
            TypeError: Errors caused by non-integer parameters input.
            ValueError: Errors caused by non-negative parameters input or the invalid ranges of 'low' and 'high'.
        """
        # Check data type of input parameters
        if not all([isinstance(num, (int, None)),
                   isinstance(low, int),
                   isinstance(high, int)]):
            raise TypeError("All input parameters must be integers")


        # Check values of input parameters
        if min(low, high) < 0:
            raise ValueError("All input parameters must be non-negative")
        if low > high:
            raise ValueError("Input parameter 'high' must be equal or larger than 'low'")
        
        # Generate random num of edges if the user does not define a fixed num
        if num is None:
            num = rand.randint(low, high)

        # Raise a value error if the user enters a negative number of nodes
        if num < 0:
            raise ValueError("Input parameter 'num' must be non-negative")

        # Get the maximum number of edges that could exist in the graph
        max_num_edges = self.__get_max_num_edges()
            
        # Generate edges while the number of edges in the graph has not reached the maximum
        while num and self.num_edges < max_num_edges:
            # Get the start and end node of the random edge
            start, end = self.unconnected_edges.get_random_edge()

            # Add an edges between the 2 nodes
            self.add_edge_to_graph(start, end)

            # Decrease the remaining num of edges to be generated
            num -= 1

        # Assigning a position for each node of the graph using the srping layout algorithm
        self.node_position = nx.spring_layout(self.G)

    def add_edge_to_graph(self, idx1: int, idx2: int) -> None:
        """Add an edge to the graph with random integer weight from 1 to 10.

        Args:
            idx1 (int): The index of the first node.
            idx2 (int): The index of the second node.

        Raises:
            TypeError: Errors caused by non-integer parameters input.
            ValueError: Errors caused by invalid range or non-existing node parameters input.
        """
        # Check data type of input parameters
        if (not isinstance(idx1, int) or 
            not isinstance(idx2, int)):
            raise TypeError("Input parameters 'idx1' and 'idx2' must be integers")
        
        # Check value ranges of input parameters
        if idx1 == idx2:
            raise ValueError("The value of 'idx1' cannot be the same as 'idx2'")
        if (idx1 not in self.node_map or 
            idx2 not in self.node_map):
            raise ValueError("The input node(s) do(es) not exist in the graph")
        
        # Get the start and end node objects from the node_map 
        start_node = self.node_map[idx1]
        end_node = self.node_map[idx2]

        # Randomly generate weight for the new edge
        weight = RSG.generate_random_edge(mean=self.edge_mean, sd=self.edge_sd)

        # Set the nodes as their neighors
        start_node.add_neighbour(end_node, weight)
        end_node.add_neighbour(start_node, weight)

        # Add the edge to the networkx visualization
        self.G.add_edge(idx1, idx2, weight=weight)

        # Remove the edge from the unconnected edges set
        if (idx1, idx2) in self.unconnected_edges:
            self.unconnected_edges.remove_edge_from_set(idx1, idx2)

        # Increase the num of edges in the graph
        self.num_edges += 1

    def shortest_path(self, starting_node: int, ending_node: int | None = None) -> int | Dict[int, int]:
        """Find the shortest path between nodes in the graph.

        Notes:
            If the user does not pass in the ending_node parameter, the program will return 
            a dictionary mapping the shortest distance to all nodes. 

        Args:
            starting_node (int): Index of the starting node.
            ending_node (int): Index of the ending node (optional).

        Returns:
            The length of the shortest path or a dictionary containing the shortest paths to all nodes.
        """
        # Check if both starting node and ending node are in the graph
        if (starting_node not in self.node_map or
            ending_node is not None and ending_node not in self.node_map):
            raise ValueError("The input nodes does not exist in the graph")

        # Create priority queue as the object of MinHeap class
        priority_queue = MinHeap([(0, self.node_map[starting_node])])  
        visited_nodes = set()

        # Create a dictionaray storing the the shortest path from the source node to every other nodes
        paths = {node_idx: float('inf') for node_idx in self.node_map.keys()}
        paths[starting_node] = 0

         # Checking each node until all nodes are visited
        while len(priority_queue) > 0:  
            # Pop the node with the smallest distance to the ending_node
            current_distance, current_node_object = priority_queue.pop()  
            current_node = current_node_object.get_index()

            # If the current node is the ending_node, the current distance will be returned
            if current_node == ending_node:
                return current_distance
            
            # Update the shortest path of a node in paths if a shorter path is found
            if current_distance < paths[current_node]:
                paths[current_node] = current_distance

             # Go through each neighbor of the current_node
            if current_node not in visited_nodes:
                visited_nodes.add(current_node)

                # If the neighbor was not visited, it will be added to priority queue
                for neighbor_object, weight in current_node_object.get_neighbours():
                    if neighbor_object.get_index() not in visited_nodes:
                        new_distance = current_distance + weight

                        # Use push method to add neighbors
                        priority_queue.push((new_distance, neighbor_object))  
        
        # Return the path dict if the user does not specify an ending node
        del paths[starting_node]
        return paths

    def __get_max_num_edges(self) -> int:
        """Calculate the maximum number of edges can be connected in the graph.

        Returns:
            An integer representing the maximum number of edges.
        """
        n = self.num_nodes
        return n * (n - 1) // 2
    
    def __randomly_connect_all_nodes(self) -> None:
        """Randomly shuffle the list of nodes and connect them."""
        # Get the all the node indicies in the graph and shuffle them
        node_indices = list(self.node_map.keys())
        shuffled_nodes = rand.shuffle(node_indices)

        # Connect each node with its previous node
        for i in range(1, len(node_indices)):
            # Get the node objects from the node map
            node1 = self.node_map[node_indices[i]]
            node2 = self.node_map[node_indices[i - 1]]

            # Generate the edge weight based on a normal distribution
            weight = RSG.generate_random_edge(mean=self.edge_mean, sd=self.edge_sd)

            # Add the nodes to their neighbour dictionaries
            node1.add_neighbour(node2, weight=weight)
            node2.add_neighbour(node1, weight=weight)

            # Add an edge in the networkx graph
            self.G.add_edge(node_indices[i], node_indices[i - 1], weight=weight)

            # Remove the edge from the unconnected edges set
            self.unconnected_edges.remove_edge_from_set(node_indices[i], node_indices[i - 1])
            
            self.num_edges += 1
            
    def graph_visualize(self, with_labels=True, node_size=700) -> None:
        """Graphical visualization of the graph using matplotlib libary for testing.

        Args:
            with_labels (bool): If True, nodes will show their ID as label.
            node_size (int): The size of the nodes.
        """
        # Drawing nodes of the graph
        nx.draw_networkx_nodes(self.G, self.node_position, node_size=node_size)
        nx.draw_networkx_labels(self.G, self.node_position, font_size=12)

        # Drawing edges of the nodes and set the width of each edge to be proportional to its weight
        edge_width = list(nx.get_edge_attributes(self.G, 'weight').values())
        nx.draw_networkx_edges(self.G, self.node_position, alpha=0.5, width=edge_width)
        
        # If the labels exist - draw them
        if with_labels:
            edge_labels = nx.get_edge_attributes(self.G, 'weight')
            nx.draw_networkx_edge_labels(self.G, self.node_position, edge_labels)

        # Axis are not needed for the project
        plt.axis('off') 

        # Visualize the graph
        plt.show() 


if __name__ == '__main__':
    graph = Graph(init_num_nodes=5, add_num_edges=3)
    print(graph)
    print(graph.shortest_path(1, 4))
    print(graph.shortest_path(1, None))
    graph.graph_visualize()
    # set weight in __randomly_connect_all_nodes and add_edge_to_graph  
